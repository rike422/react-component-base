#!/usr/bin/env node

const process = require('process');
const nunjucks = require('nunjucks');
const program = require('commander');
const changCase = require('change-case');
const inquirer = require('inquirer');
const fs = require('fs');
const path = require('path');
const TEMPLATE_PATH = path.join(__dirname, '../', 'templates');
const mkdirp = require('mkdirp');

function render(template, context) {
  return new Promise(function (resolve) {
    nunjucks.render(path.join(TEMPLATE_PATH, template.from), context, (err, content) => {
      if (err != null) {
        console.error(err);
        process.exit(1);
      }
      mkdir(template.to);
      writeFile(template.to, content);
      resolve();
    });
  });
}

function resolveConflict(_template) {
  return inquirer.prompt({
    type: 'expand',
    name: 'choice',
    message: `Overwrite ${_template.to}? (enter "h" for help) [Ynaqh]`,
    choices: [
      {
        key: 'y',
        name: 'yes, overwrite',
        value: 'overwrite',
      },
      {
        key: 'a',
        name: 'all, Overwrite this one and all next',
        value: 'overwrite_all',
      },
      {
        key: 'n',
        name: 'no, do not overwrite',
        value: 'no',
      },
      new inquirer.Separator(),
      {
        key: 'q',
        name: 'Quit this process',
        value: 'quit',
      },
    ],
  }).then((answer) => answer);
}

function mkdir(outputPath, cb) {
  mkdirp(path.join(__dirname, '../', path.dirname(outputPath)));
}

function writeFile(path, content) {
  console.log(`write ${path}`);
  fs.writeFile(path, content);
}

program.version('0.0.1');
program
  .command('generate <name>')
  .description('Generate new react component')
  .action((name, args) => {
    const context = {
      className: changCase.pascalCase(name),
      directoryName: changCase.paramCase(name),
      pkg: require('../package.json'),
    };
    const GENERATE_FILES = [
      {
        from: path.join('src', 'component', 'component.jsx.njk'),
        to: path.join('src', 'components', context.directoryName, `${context.directoryName}.jsx`),
      },
      {
        from: path.join('src', 'component', 'README.md.njk'),
        to: path.join('src', 'components', context.directoryName, 'README.md'),
      },
      {
        from: path.join('src', 'component', 'style.scss.njk'),
        to: path.join('src', 'components', context.directoryName, 'style.scss'),
      },
      {
        from: path.join('src', 'stories', 'story.js.njk'),
        to: path.join('src', 'components', 'stories', `${context.directoryName}.jsx`),
      },
      {
        from: path.join('tests', 'test.js.njk'),
        to: path.join('test', 'components', context.directoryName, `${context.directoryName}_spec.jsx`),
      },
    ];
    GENERATE_FILES.reduce((promise, template) => {
      return promise.then((answerHistory) => {
        var answerHistory = answerHistory || [];
        if (fs.existsSync(template.to) && (answerHistory.every((history) => history !== 'overwrite_all'))) {
          return resolveConflict(template).then((answer) => {
            answerHistory.push(answer.choice);
            switch (answer.choice) {
              case 'overwrite':
              case 'overwrite_all':
                return render(template, context).then(() => Promise.resolve(answerHistory));
              case 'no':
                return Promise.resolve(answerHistory);
              case 'quit':
                console.log('Aborting...');
                process.exit(0);
                break;
            }
          });
        }
        return render(template, context).then(() => Promise.resolve(answerHistory));
      });
    }, Promise.resolve([])).catch(console.error);
  });

program.parse(process.argv);
